from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import pandas as pd
import re
import time
from selenium.common.exceptions import NoSuchElementException, ElementNotVisibleException, WebDriverException

def clean_text(text):
    # Use regex to clean up predefined labels from the text
    text = re.sub(r"^(FUNDER|RECIPIENT)\s*", "", text, flags=re.IGNORECASE)
    # Search for keywords and extract relevant information after them
    match = re.search(r"(?:TOTAL AMOUNT:|FISCAL YEAR:|GRANT DURATION:|PRIMARY SUBJECT:|POPULATION SERVED:|SUPPORT STRATEGY:|TRANSACTION TYPE:|GRANT PROGRAM AREA:)?\s*\$?\s*(.*)", text, flags=re.IGNORECASE)
    # Return the cleaned text or "Not Available" if the pattern does not match
    return match.group(1) if match else "Not Available"

def safe_find_text_by_xpath(driver, xpath):
    # Safely attempt to find an element by its XPath and extract text
    try:
        element_text = driver.find_element(By.XPATH, xpath).text
        # If the element is found and has text, clean it, else return "Not Available"
        return clean_text(element_text) if element_text.strip() else "Not Available"
    except (NoSuchElementException, ElementNotVisibleException, WebDriverException) as e:
        # If the element is not found or an error occurs, return "Not Available"
        return "Not Available"

# Initialize the Chrome WebDriver
driver = webdriver.Chrome()
# Load the webpage
driver.get('https://maps.foundationcenter.org/#/list/?subjects=all&popgroups=all&years=all&location=6254926&excludeLocation=0&geoScale=ADM1&layer=geo_area&boundingBox=-139.219,-31.354,135,66.513&gmOrgs=all&recipOrgs=all&tags=all&keywords=&pathwaysOrg=&pathwaysType=&acct=raceequpopup&typesOfSupport=all&transactionTypes=all&amtRanges=all&minGrantAmt=0&maxGrantAmt=0&gmTypes=all&recipTypes=all&minAssetsAmt=0&maxAssetsAmt=0&minGivingAmt=0&maxGivingAmt=0&andOr=0&includeGov=1&custom=all&customArea=all&indicator=&dataSource=oecd&chartType=trends&multiSubject=1&listType=recip&windRoseAnd=undefined&zoom=0')
time.sleep(2)

# Close the initial modal popup that might block elements on the page
close_button = driver.find_element(By.CSS_SELECTOR, 'button[class="close"]')
close_button.click()
time.sleep(1)

# Clicks to open grant section
recipients = driver.find_element(By.PARTIAL_LINK_TEXT, 'GRANTS')
recipients.click()
time.sleep(1)

# List to hold all collected grant data
all_data = []

def extract_data():
    # Locate all rows in the grant table
    ##rows = driver.find_elements(By.XPATH, '//*[@id="table-id"]/tbody/tr')
    for row in rows:
        # Click the Details button for each row
        ##details_button = row.find_element(By.CLASS_NAME, 'details-button-class')
        details_button.click()
        time.sleep(1)

        # Extract data from the detail modal and store it in a dictionary
        grant_data = {
            "Grant Funder Name": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[2]'),
            "Grant Recipient Name": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[3]'),
            "Grant Total Amount": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[4]'),
            "Grant Fiscal Year": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[5]'),
            "Grant Duration": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[6]'),
            "Grant Program Area": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[7]'),
            "Grant Primary Subject": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[8]'),
            "Grant Population Served": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[9]'),
            "Grant Support Strategy": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[10]'),
            "Grant Transaction Type": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[1]/div[11]'),
            "Grant Description": safe_find_text_by_xpath(driver, '//*[@id="details-modal"]/div[2]/div[1]')
        }
        all_data.append(grant_data)

        # Close the details modal to return to the main list
        ##close_details_button = driver.find_element(By.XPATH, '//*[@id="close-details-button-xpath"]')
        close_details_button.click()
        time.sleep(1)


#Extract Data From First Page 
extract_data()


# Handle pagination by iterating through pages
wait = WebDriverWait(driver, 10)
for page_num in range(2, 100):  
    try:
        # Locate the page buttons at the bottom of the table
        page_buttons = driver.find_elements(By.XPATH, '//*[@id="fm-list-1gmfm-list-table_wrapper"]/div[2]/div[2]/div/ul/li/a')
        for button in page_buttons:
            # Click on the page button if it matches the current page number
            if button.text == str(page_num):
                print(f"Navigating to page {page_num} using button: {button.text}")
                button.click()
                # Wait for the table to refresh to ensure data consistency
                ##wait.until(EC.staleness_of(driver.find_element(By.XPATH, '//*[@id="table-id"]/tbody/tr')))
                extract_data()
                break
    except Exception as e:
        print(f"An error occurred while navigating to page {page_num}: {e}")
        break

# Save the collected data to a CSV file
df = pd.DataFrame(all_data)
df.to_csv("Grant_Details.csv", index=False)
print("Data extraction complete.")

# Clean up by closing the browser
driver.quit()
